/*
困难
一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。
我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。
骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。
有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；
其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。
为了尽快到达公主，骑士决定每次只向右或向下移动一步。
编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。

动态规划( O(n^2) )：
设一个二维dp数组，每个元素表示骑士到达该位置时初始的最低健康点数。从最右下角开始递推。
对于最右下角位置，若房间里的值为负数，则初始最低健康值为1-该值（健康点数最低为1）；若房间里值为正数，则初始健康点数为1。
对于最后一行（列），某位置右（下）边dp值减去该位置房间里的值，若为正数，则这个正数就是该位置的初始健康点数(dp值)；若为非正数，则初始健康点数置为1。
其余情况，对于某位置，选取下边或右边dp较小的，减去该位置房间里的值，若为正数，则这个正数就是该位置的初始健康点数；若为非正数，则初始健康点数置为1。
递推关系：
dp[i][j] = max(1, 1 - dungeon[i][j]);       最右下角位置
dp[i][j] = max(1, dp[i][j+1] - dungeon[i][j]);      最后一行
dp[i][j] = max(1, dp[i+1][j] - dungeon[i][j]);      最后一列
dp[i][j] = max(1, min(dp[i][j+1],dp[i+1][j]) - dungeon[i][j]);      其它

执行用时 : 12 ms, 在Dungeon Game的C++提交中击败了19.01% 的用户
内存消耗 : 9.9 MB, 在Dungeon Game的C++提交中击败了0.00% 的用户
*/
class Solution {
private:
    vector<vector<int>> dp;
public:
    int calculateMinimumHP(vector<vector<int>>& dungeon) {
        if(dungeon.empty())
            return 0;
        int m = dungeon.size(), n = dungeon[0].size();
        dp = vector<vector<int>>(m, vector<int>(n));
        dp[m-1][n-1] = max(1, 1 - dungeon[m-1][n-1]);       //初始化最右下角位置
        for(int i = m-2; i >= 0; --i)       //初始化最后一列
            dp[i][n-1] = max(1, dp[i+1][n-1] - dungeon[i][n-1]);
        for(int j = n-2; j >= 0; --j)       //初始化最后一行
            dp[m-1][j] = max(1, dp[m-1][j+1] - dungeon[m-1][j]);
        for(int i = m-2; i >= 0; --i)       //按照其它情况的递推关系递推
            for(int j = n-2; j >= 0; --j)
                dp[i][j] = max(1, min(dp[i][j+1],dp[i+1][j]) - dungeon[i][j]);
        return dp[0][0];
    }
};
