/*
中等
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个位置。
示例 1:

输入: [2,3,1,1,4]
输出: true
解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。
示例 2:

输入: [3,2,1,0,4]
输出: false
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。

时间复杂度为O(n)，算法思想：
（１）为方便后面的步骤，总是将nums数组最后一个元素置为１;
（２）将数组以0为分隔符，划分为几个区间，区间元素均不包括0，若有连续0，则以连续0中最后一个0作为分隔，如[3,2,2,0,3,0,0,4]，则划分为３个区间：
[3,2,2],[3],[4]，将分隔的位置记录到zeros数组[3,6]。每个区间元素可相互到达，它们是等价的，以0,1,2号区间表示;
（３）若zeros数组为空，返回真，表示可达；
（４）从第一个区间开始，将其作为搜索区间,遍历该区间每一个元素，可得到该区间最远可以到达的位置p，计算方式为每一个元素值与其下标之和。算出p所在区间号。
（５）若p所在区间仍在当前区间，则不可达。若p所在区间号大于等于最后一个区间号，则返回真；
（６）否则以p所在区间作为搜索区间重新进行上述搜索；

执行用时 : 16 ms, 在Jump Game的C++提交中击败了37.34% 的用户
内存消耗 : 9.7 MB, 在Jump Game的C++提交中击败了0.87% 的用户
*/

class Solution {
private:
    vector<int> mnums;
public:
    bool canJump(vector<int>& nums) {
        if(nums.empty())
            return false;
        nums[nums.size()-1] = 1;
        int start, p, i, j;
        vector<int> zeros;                      //存储　0　元素下标
        for(i = 0; i < nums.size(); ++i){       //该for循环确立分隔符 0 的位置
            if(nums[i] == 0){
                j = zeros.size();
                if(j > 0 && zeros[j-1] + 1 == i)
                    zeros[j-1] = i;
                else
                    zeros.push_back(i);
            }
        }
        start = 0;                                      //开始搜索位置初始为0
        for(i = 0; i < zeros.size();){                  //第一次循环从第0号区间开始，下一次循环为p位置所在区间号
            p = start + nums[start];
            for(j = start; j < zeros[i]; ++j)
                p = max(j + nums[j], p);               //p表示当前区间最远可达的位置
            if(p <= zeros[i])                          //p位置若在当前区间，则不可达
                return false;
            ++i;                                              //从当前区间的下一个区间开始寻找以确定p位置所在的区间号
            while(i < zeros.size() && zeros[i] < p){++i;};    //寻找p所在区间,并置为下一轮的搜索区间
            start = zeros[i-1] + 1;                           //搜索的起始位置为新搜索区间的第一个位置
        }
        return true;
    }
};
